from plots import Plot,PlotError,PlotState,Chapter
import context
import items
import maps
import randmaps
import waypoints
import monsters
import dialogue
import services
import teams
import characters
import namegen
import random
import container
import aid

# Shortie Done-in-one Dungeon Monkey Adventure
# - A small adventure, typically consisting of a single dungeon or wilderness
#   area.
# - Despite the limited area, see how interesting you can make it.
# - This will be dynamically loaded into an existing campaign.

class ShortieStub( Plot ):
    LABEL = "SHORTIE"

    # This plot gets placed in the global scripts and sets itself as the
    # "world" of its chapter. This means that all scenes generated by subplots
    # should be stored inside the plot itself, making cleanup easy. I hope.
    scope = True
    active = False

    SHORTIE_GRAMMAR = {
        # [ADVENTURE] is the top level token- it will expand into a number of
        # high level tokens.
        "[ADVENTURE]": [ "SDI_VILLAGE SDI_ENEMY_FORT SDI_BIGBOSS",
            ],

        "[ENEMY_BASE]": [ "SDI_ENEMY_FORT SDI_ENEMY_BARRACKS",
            ],

        "[ENEMY_GOAL]": [ "SDI_SUPERWEAPON",
            "SDI_BIGBOSS"
            ],

        "[IMPERILED_PLACE]": [ "SDI_AMBUSH SDI_VILLAGE",
            ],
    }
    def custom_init( self, nart ):
        """Create the chapter."""
        self.chapter = Chapter( start_rank=nart.start_rank, end_rank=nart.end_rank, world=self )
        self.chapter.root = self
        self.contents = container.ContainerList(owner=self)
        self.rank = nart.start_rank
        if not self.setting:
            self.setting = context.SET_RENFAN

        # Generate a plot outline for the adventure. We will do this using a
        # context free grammar expansion of the token [ADVENTURE]. The resultant
        # string will be a list of subplot request labels.
        subplot_list = self.register_element( "SHORTIE_OUTLINE", list( dialogue.grammar.convert_tokens( "[ADVENTURE]", self.SHORTIE_GRAMMAR ).split() ) )

        # Assemble the outline into an adventure. Basically, add a subplot of
        # each generated type, in order. Each subplot describes a stage of the
        # mini adventure- usually a single scene, maybe also several scenes or
        # part of a scene, whatever.
        prev_subplot = self
        self.genplots = list()
        ident = None
        for spr in subplot_list:
            if spr is subplot_list[-1]:
                ident = "_conclusion"
            next_subplot = self.add_sub_plot( nart, spr,
                PlotState().based_on(prev_subplot), ident=ident )
            self.genplots.append( next_subplot )
            if prev_subplot != self:
                # Connect the OUT_ENTRANCE of the prev to the IN_ENTRANCE of the
                # next.
                pe,ne = prev_subplot.elements["OUT_ENTRANCE"], next_subplot.elements["IN_ENTRANCE"]
                pe.destination,pe.otherside = next_subplot.elements["IN_SCENE"],ne
                ne.destination,ne.otherside = prev_subplot.elements["OUT_SCENE"],pe
            # That which was new has now become old.
            prev_subplot = next_subplot

        # Set the adventure entrance to the IN_SCENE of the first generated
        # subplot.
        self._adventure_entrance = (self.genplots[0].elements.get( "IN_SCENE" ),self.genplots[0].elements.get( "IN_ENTRANCE" ))
        #exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        #self.register_element( "_EXIT", exit )
        #exit.plot_locked = True
        self.mr_subplot = self.genplots[0]

        self._do_message = True

        return True
    def _EXIT_menu( self, thingmenu ):
        thingmenu.desc = "This appears to be the way out."
        thingmenu.add_item( "Leave this adventure.", self.use_exit )
        thingmenu.add_item( "Stay here a bit longer.", None )
    def _ENTRANCE_menu( self, thingmenu ):
        self._EXIT_menu( thingmenu )
    def use_exit( self, explo ):
        explo.alert( "[=CONCLUSION]" )
        explo.give_gold_and_xp( self.rank*150+random.randint(1,200), (self.rank+1)*250 )
        self.end_adventure( explo.camp )
    def _conclusion_WIN( self, explo ):
        # The conclusion has been won. Activate the exit.
        exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        self.register_element( "_EXIT", exit )
        exit.plot_locked = True
        exit = self.genplots[-1].elements.get( "IN_ENTRANCE" )
        self.register_element( "_ENTRANCE", exit )
        exit.plot_locked = True

    def begin_adventure( self, explo, exit_destination, exit_entrance ):
        # Unpack the adventure entrance stored during generation.
        self.active = True
        explo.camp.destination,explo.camp.entrance = self._adventure_entrance
        self._adventure_exit = (exit_destination, exit_entrance)
        explo.alert( "[=INTRO]" )

    def end_adventure( self, camp ):
        # Remove this adventure from campaign, move PCs to original place.
        camp.destination,camp.entrance = self._adventure_exit
        camp.scripts.remove( self )
        self.remove()

    DIALOGUE_GRAMMAR = {
        "[=CONCLUSION]": [ "After [-achievement] and [++achievement], you return home in victory.",
            ],
        "[=INTRO]": [ "You have been sent to bring [+SDI_BIGBOSS:name] the [+SDI_BIGBOSS:type] to justice. So far you have tracked them to [=location].",
            "The [+SDI_VILLAGE] has called for a hero. [INTRO_PROBLEM]"
            ],
        "[INTRO_PROBLEM]": [ "Travelers passing through [+SDI_AMBUSH:name] have gone missing.",
            "A [+SDI_BIGBOSS:type] named [+SDI_BIGBOSS:name] has been causing problems.",
            "[=SUMMARY]",
            ],
        "[RUMOUR]": [   "[rumourleadin] [warning].",
            ],
        "[SHORTIE_SUMMARY]": [ "You already know that [-warning].",
            "[=SUMMARY]"
            ],
        "[SHORTIE_PROBLEM]": [ "[++SUMMARY]","[+SUMMARY]"
            ],
        "[warning]": [ "[+warning]","[=warning]",
            ],
    }

    def get_dialogue_grammar( self, npc, explo ):
        """Return any grammar rules appropriate to this situation."""
        gram = dialogue.grammar.absorb( dict(), self.DIALOGUE_GRAMMAR )
        prefix = "-"
        for sp in self.genplots:
            g2 = sp.get_sdi_grammar()
            if sp is self.mr_subplot:
                prefix = "="
            elif prefix == "=":
                prefix = "+"
            for k,v in g2.iteritems():
                a,b,c = k.partition("[")
                mod_k = b + prefix + c
                if mod_k not in gram:
                    gram[mod_k] = list()
                gram[mod_k] += v
                if sp is self.genplots[-1]:
                    # Add a special mention for the conclusion.
                    mod_k = b + "++" + c
                    if mod_k not in gram:
                        gram[mod_k] = list()
                    gram[mod_k] += v
        return gram

    def t_START( self, explo ):
        if self._do_message:
            self._do_message = False
        # Determine the most recently entered subplot...
        for sp in self.genplots:
            if explo.scene is sp.elements["IN_SCENE"]:
                if self.genplots.index(sp) > self.genplots.index(self.mr_subplot):
                    self.mr_subplot = sp
    def t_COMBATOVER( self, explo ):
        # If the party has died, end this plot gracefully.
        if not explo.camp.first_living_pc():
            explo.camp.destination,explo.camp.entrance = self._adventure_exit
            explo.camp.scripts.remove( self )
            self.remove()

class SDIPlot( Plot ):
    # Like a normal plot, but with extra functions for shortie adventures.
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        # Grammar will be prefixed depending on position:
        # "-" for a subplot the PC has already visited
        # "=" for the current subplot
        # "+" for future subplots
        # "++" for the adventure conclusion
        return dict()

# Each shortie component should include:
# IN_SCENE,IN_ENTRANCE: Scene/Entrance where the subplot is entered.
# OUT_SCENE, OUT_ENTRANCE: Scene/Entrance where the subplot is exited.
#  -Note that IN_ENTRANCE need not be a valid gate; if not, transit from
#   previous subplot is one-way only.
#  -If OUT_ENTRANCE is plot_locked, unlock it before triggering WIN.
#
# Each shortie component can define the following SDI grammar tags:
#  [achievement] Subplot's win condition, in gerund (-ing) form. Can be omitted
#           if nothing much was achieved.
#  [GO_QUEST]   Describe the win condition for this subplot in imperative form.
#  [INTRO]  An introduction to be printed if the adventure starts in this
#           subplot.
#  [location]   A location of interest within the subplot. Optional.
#  [SUMMARY]    A summary of subplot's state, written from player-aligned
#     perspective, in simple present tense.
#  [warning]    A caution for the PC. Frequently encountered as a rumour.
#
# 
#



#  SDI_ENEMY_FORT
#   There's an enemy fortress to discover in the wilderness, and you need to
#   find a way in. In the simplest case this involves just fighting the guards
#   at the front door.
# Win Condition:
#   Gain access to the fortress. This may be as simple as showing up.
# Grammar Tags:
#   [SDI_ENEMY_FORT:location]   The rough location of the enemy fort
# To do:
# - Well-guarded and obvious fortress.
# - Pet guarded gate
# - Locked fortress
# - Can of Wyrms: Small courtyard full of enemies with unlocked puzzle door.
# - Unguarded fortress for low levels.

class BasicCaveHideout( SDIPlot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack()
        myroom.contents.append( myent )

        # Create the fortress room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.MountainRoom(tags=(context.GOAL,)), dident="LOCALE" )
        antagonist = self.elements.get( "ANTAGONIST" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=50, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        fortress.contents.append( team )

        # Register the cave stuff.
        self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.CavernDungeon(antagonist) )

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER)] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank-3,self.rank+1,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+1, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            fortress.contents.append( boss )

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.DungeonEntrance()
        myexit.mini_map_label = "Cave Fortress"
        myexit.plot_locked = True
        self._door_locked = True
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        # Add some extra pressure.
        if random.randint(1,4) != 4:
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "locating the enemy base",
                ],
            "[GO_QUEST]": ["Gain access to the enemy fortress in the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "There's an enemy base in the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "the fortress in the {} is very well guarded".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to enter the fortress.")
            explo.check_trigger( "WIN", self )



# SDI_ENEMY_BARRACKS

# SDI_BLOCKED_GATE

# SDI_HIDDEN_BASE

# SDI_WILD_DUNGEON

# SDI_SUPERWEAPON

# SDI_BIGBOSS
#
# Win Condition:
#   Kill the boss, usually.
# Grammar Tags:
#   [SDI_BIGBOSS:name]   The name of the boss
#   [SDI_BIGBOSS:type]   The type of the boss (optional)
# To do:
# - NPC big boss
# - Smaller boss with a big pet

class BossInABox( SDIPlot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 45, 45,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=50,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.northwest,randmaps.anchors.north,randmaps.anchors.northeast)) )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        myhabitat[ context.MTY_BOSS ] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )

            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) <= self.rank:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Defeat {}.".format(self.elements["ENEMY"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].monster_name,],
            "[SUMMARY]": [ "{} is a [negative_adjective] {}.".format(str(self.elements["ENEMY"]),self.elements["ENEMY"].monster_name),
                ],
            "[warning]":    ["{} is a tough enemy".format(self.elements["ENEMY"]),
                ],
        }
        return mygram


# SDI_AMBUSH
# The party has been ambushed! Oh noes!
#
# Win Condition:
#   Just show up, usually. Surviving is its own reward.
# Grammar Tags:
#   "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
# To do:
# - Novice ambush: Arrive after caravan destroyed, talk to survivors, no fight.
# - Too late ambush: Arrive after destruction, fight beasts at site. After
#   battle get message confirming that humanoids were behind the attack.
# - Trap ambush: Find destroyed caravan; searching cart brings out enemies.

class ImmediateAmbush( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 40, 40,
          randmaps.WildernessPath, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        myent = waypoints.Waypoint()
        ambush_room.contents.append( myent )
        ambush_room.priority = 0
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction( context.GEN_GOBLIN ) )

        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )

        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("Without warning, you are ambushed by forces of the {}!".format(self.elements["ANTAGONIST"]))
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
            explo.check_trigger( "WIN", self )
            self._do_message = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "battling the {} on the {}".format(self.elements["ANTAGONIST"],self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["The {} will take you where you need to go.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                    "You travel to [+SDI_VILLAGE:name] for the annual [thing] festival. The path is peaceful and pleasant... too pleasant.",
                    "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
            "[SUMMARY]": [ "The {} has frequently been attacked by {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        return mygram


class AmbushInterrupted( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction( context.GEN_GOBLIN ) )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.WildernessPath, biome, setting=self.setting,
          fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.Waypoint()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        friendlies = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        npc = self.register_element( "NPC",
         monsters.generate_npc(team=friendlies,rank=self.rank+1,upgrade=True),
         dident="_AMBUSHROOM" )
        self._reward_ready = True
        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("You hear the sounds of conflict on the path ahead...")
            explo.check_trigger( "WIN", self )
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            ol.append( dialogue.Offer( "Thanks for your help against the {}, but I fear [warning].".format(self.elements["ANTAGONIST"]) ,
             context = context.ContextTag([context.HELLO]) ) )
        return ol
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["The {} will take you where you need to go.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [    "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                "You travel to [+SDI_VILLAGE:name]. This area has recently been attacked by the {}.".format(self.elements["ANTAGONIST"]),
                "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
            "[SUMMARY]": [ "The {} has frequently been attacked by {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        if self.elements["NPC"].is_alright() and not self._reward_ready:
            mygram["[achievement]"] = [ "saving {} from the {}".format(self.elements["NPC"],self.elements["ANTAGONIST"]),
                ]
        return mygram



# SDI_VILLAGE
#
# Win Condition:
#   Just show up, usually. A village is its own reward.
# Grammar Tags:
#    [SDI_VILLAGE:name] The village name, usually "village of #".
# To do:
# - Too late village: has already been destroyed, may find survivors. Or not.
# - Orc Prisoners: Village has been captured by orcs; rescue them from mine.
#   Survivors then help you find way to next chapter.
# - Dwarven village: Have to go underground to find it.
# - Elf village: Likewise hidden from plain sight.
# - Fort Under Siege: Barred from entering fort; doors will open after the
#   enemies have been defeated.
# - Hot Springs Village: Healing location, priestly stuff.
# - Nature Village: Druidish and rangerish stuff. Stonehenge?
# - Secret Magic Village: Wizardly stuff.
# - Athletic Village: Warrior stuff.
# - Hermit Village: Hey hey we're the monk-ees.

class BoringVillage( SDIPlot ):
    LABEL = "SDI_VILLAGE"
    # Create a small village. Add an NPC to provide advice and help.
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        """Create map, fill with city + services."""
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "ARCHITECTURE", randmaps.architect.Village(biome.biome))
        myscene,mymapgen = randmaps.architect.design_scene( 80, 80,
          randmaps.WildernessPath, biome,secondary=archi,setting=self.setting)
        myscene.desctags.append( context.DES_CIVILIZED )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        castle = self.register_element( "CITY",
         randmaps.rooms.VillageRoom( width=25,height=25,anchor=randmaps.anchors.middle,
         tags=(context.CIVILIZED,context.ROOM_PUBLIC), parent=myscene ) )
        castle.priority = 50
        castleroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=castle )
        myteam = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        castle.contents.append( myteam )
        castleroom.contents.append( monsters.generate_npc(team=myteam) )
        castleroom.contents.append( monsters.generate_npc(team=myteam) )

        # Create the village elder.
        elder = monsters.generate_npc(team=myteam,rank=self.rank+1,
          job=monsters.base.Elder,upgrade=True)
        self.register_element("NPC",elder)
        castleroom.contents.append(elder)
        self._reward_given = False

        # Create the entrance at the beginning
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        self._message_ready = True

        self.add_sub_plot( nart, "VILLAGE_RANDOMSHOP" )
        self.add_sub_plot( nart, "CITY_INN" )
        self.add_sub_plot( nart, "CITY_TEMPLE" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        #self.add_sub_plot( nart, "TEST_FEATURE", necessary=False )
        return True

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["Travel to the village of {}.".format(self.elements["LOCALE"]),
                ],
            "[SDI_VILLAGE:name]": [ "village of {}".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "You arrive in the village of {}. [INTRO_PROBLEM]".format(self.elements["LOCALE"]),
                "This was supposed to be a nice relaxing trip to the {}. Of course, things rarely go according to plan for adventurers.".format(self.elements["LOCALE"]),
                ],
            "[location]": ["village of {}".format(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The village of {} has seen better times.".format(self.elements["LOCALE"]),
                "The village of {} lives in fear of [+SDI_BIGBOSS:name].".format(self.elements["LOCALE"]),
                "The village of {} is under attack by enemies who come from [+SDI_ENEMY_FORT:location].".format(self.elements["LOCALE"]),
                ],
        }
        return mygram
    def accept_quest( self, explo ):
        self._reward(explo)
        self._reward_given = True
    def reject_quest( self, explo ):
        self.chapter.root.end_adventure(explo.camp)
    def NPC_offers( self, explo ):
        ol = list()
        if not hasattr( self, "_reward" ):
            # Generate aid for the NPC to give the party.
            self._reward = aid.ProvisionAid( self.rank, explo.camp,
             self.elements["NPC"],
             self.chapter.root.genplots[-1].elements.get("ENEMY"),
             self.elements.get("ANTAGONIST"))
        if not self._reward_given:
            r1 = dialogue.Reply( "Yes, we will.",
             destination=dialogue.Offer( "[+GO_QUEST] {}".format( self._reward.get_speech() ),
             effect=self.accept_quest ) )
            r2 = dialogue.Reply( "No thanks.",
             destination=dialogue.Offer( "[REFUSE_QUEST]",
             effect=self.reject_quest ) )
            ol.append( dialogue.Offer( "[SHORTIE_SUMMARY] [SHORTIE_PROBLEM] Will you help us?",
             context = context.ContextTag([context.PROBLEM,context.LOCAL]),
             replies = [r1,r2] ) )
        else:
            pass
        return ol
    def t_START( self, explo ):
        if self._message_ready:
            self._message_ready = False
            explo.check_trigger( "WIN", self )



# SDI_OUTPOST

# SDI_RECON


