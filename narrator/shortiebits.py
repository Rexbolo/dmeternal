from plots import Plot,PlotError,PlotState,Chapter
import context
import items
import maps
import randmaps
import waypoints
import monsters
import dialogue
import services
import teams
import characters
import namegen
import random
import container

# Shortie Done-in-one Dungeon Monkey Adventure
# - A small adventure, typically consisting of a single dungeon or wilderness
#   area.
# - Despite the limited area, see how interesting you can make it.
# - This will be dynamically loaded into an existing campaign.

class ShortieStub( Plot ):
    LABEL = "SHORTIE"

    # This plot gets placed in the global scripts and sets itself as the
    # "world" of its chapter. This means that all scenes generated by subplots
    # should be stored inside the plot itself, making cleanup easy. I hope.
    scope = True
    active = False

    SHORTIE_GRAMMAR = {
        # [ADVENTURE] is the top level token- it will expand into a number of
        # high level tokens.
        "[ADVENTURE]": [ "SDI_AMBUSH SDI_VILLAGE SDI_ENEMY_FORT SDI_BIGBOSS",
            ],

        "[ENEMY_BASE]": [ "SDI_ENEMY_FORT SDI_ENEMY_BARRACKS",
            ],

        "[ENEMY_GOAL]": [ "SDI_SUPERWEAPON",
            "SDI_BIGBOSS"
            ],

        "[IMPERILED_PLACE]": [ "SDI_AMBUSH SDI_VILLAGE",
            ],
    }
    def custom_init( self, nart ):
        """Create the chapter."""
        self.chapter = Chapter( start_rank=nart.start_rank, end_rank=nart.end_rank, world=self )
        self.chapter.root = self
        self.contents = container.ContainerList(owner=self)
        self.rank = nart.start_rank
        if not self.setting:
            self.setting = context.SET_RENFAN

        # Generate a plot outline for the adventure. We will do this using a
        # context free grammar expansion of the token [ADVENTURE]. The resultant
        # string will be a list of subplot request labels.
        subplot_list = self.register_element( "shortie_outline", list( dialogue.grammar.convert_tokens( "[ADVENTURE]", self.SHORTIE_GRAMMAR ).split() ) )

        # Assemble the outline into an adventure. Basically, add a subplot of
        # each generated type, in order. Each subplot describes a stage of the
        # mini adventure- usually a single scene, maybe also several scenes or
        # part of a scene, whatever.
        prev_subplot = self
        self.genplots = list()
        ident = None
        for spr in subplot_list:
            if spr is subplot_list[-1]:
                ident = "_conclusion"
            next_subplot = self.add_sub_plot( nart, spr,
                PlotState().based_on(prev_subplot), ident=ident )
            self.genplots.append( next_subplot )
            if prev_subplot != self:
                # Connect the OUT_ENTRANCE of the prev to the IN_ENTRANCE of the
                # next.
                pe,ne = prev_subplot.elements["OUT_ENTRANCE"], next_subplot.elements["IN_ENTRANCE"]
                pe.destination,pe.otherside = next_subplot.elements["IN_SCENE"],ne
                ne.destination,ne.otherside = prev_subplot.elements["OUT_SCENE"],pe
            # That which was new has now become old.
            prev_subplot = next_subplot

        # Set the adventure entrance to the IN_SCENE of the first generated
        # subplot.
        self._adventure_entrance = (self.genplots[0].elements.get( "IN_SCENE" ),self.genplots[0].elements.get( "IN_ENTRANCE" ))
        exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        self.register_element( "_EXIT", exit )
        exit.plot_locked = True
        self.mr_subplot = self.genplots[0]

        self._do_message = True

        return True
    def _EXIT_menu( self, thingmenu ):
        thingmenu.desc = "This appears to be the way out."
        thingmenu.add_item( "Leave this adventure.", self.use_exit )
    def use_exit( self, explo ):
        self.end_adventure( explo.camp )

    def begin_adventure( self, explo, exit_destination, exit_entrance ):
        # Unpack the adventure entrance stored during generation.
        self.active = True
        explo.camp.destination,explo.camp.entrance = self._adventure_entrance
        self._adventure_exit = (exit_destination, exit_entrance)
        explo.alert( "[=INTRO]" )

    def end_adventure( self, camp ):
        # Remove this adventure from campaign, move PCs to original place.
        camp.destination,camp.entrance = self._adventure_exit
        camp.scripts.remove( self )
        self.remove()

    DIALOGUE_GRAMMAR = {
        "[=INTRO]": [ "You have been sent to bring [+SDI_BIGBOSS:name] the [+SDI_BIGBOSS:type] to justice. So far you have tracked them to [=location].",
            "The [+SDI_VILLAGE] has called for a hero. [INTRO_PROBLEM]"
            ],
        "INTRO_PROBLEM": [ "Travelers passing through [+SDI_AMBUSH:name] have gone missing.",
            "A [+SDI_BIGBOSS:type] named [+SDI_BIGBOSS:name] has been causing problems.",
            ],
        "[RUMOUR]": [   "[rumourleadin] [warning].",
            ],
        "[warning]": [ "[+warning]","[=warning]",
            ],
    }

    def get_dialogue_grammar( self, npc, explo ):
        """Return any grammar rules appropriate to this situation."""
        gram = dialogue.grammar.absorb( dict(), self.DIALOGUE_GRAMMAR )
        prefix = "-"
        for sp in self.genplots:
            g2 = sp.get_sdi_grammar()
            if sp is self.mr_subplot:
                prefix = "="
            elif prefix == "=":
                prefix = "+"
            for k,v in g2.iteritems():
                a,b,c = k.partition("[")
                mod_k = b + prefix + c
                if mod_k not in gram:
                    gram[mod_k] = list()
                gram[mod_k] += v
        return gram

    def t_START( self, explo ):
        if self._do_message:
            self._do_message = False
        # Determine the most recently entered subplot...
        for sp in self.genplots:
            if explo.scene is sp.elements["IN_SCENE"]:
                if self.genplots.index(sp) > self.genplots.index(self.mr_subplot):
                    self.mr_subplot = sp

class SDIPlot( Plot ):
    # Like a normal plot, but with extra functions for shortie adventures.
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        # Prefix may be +, -, or =, depending on whether this is a previous,
        # equivalent, or future shortie plot.
        return dict()

# Each shortie component should include:
# IN_SCENE,IN_ENTRANCE: Scene/Entrance where the subplot is entered.
# OUT_SCENE, OUT_ENTRANCE: Scene/Entrance where the subplot is exited.
#  -Note that IN_ENTRANCE need not be a valid gate; if not, transit from
#   previous subplot is one-way only.
#  -Also note that the destinations/behaviour of the entrances will be set by
#   the parent SHORTIE plot. If this plot requires control of the entrances
#   itself, move the declared entrance to an intermediate scene and control
#   access to that scene.
#
# Each shortie component should define the following grammar tags:
#  [INTRO]  An introduction to be printed if the adventure starts in this
#           subplot.
#  [location]   A location of interest within the subplot. Optional.
#



#  SDI_ENEMY_FORT
#   There's an enemy fortress to discover in the wilderness, and you need to
#   find a way in. In the simplest case this involves just fighting the guards
#   at the front door.
# Grammar Tags:
#   [SDI_ENEMY_FORT:location]   The rough location of the enemy fort
# To do:
# - Well-guarded and obvious fortress.
# - Pet guarded gate
# - Locked fortress

class BasicCaveHideout( SDIPlot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        myscene = maps.Scene( 50, 50, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.ForestScene( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack()
        myroom.contents.append( myent )

        # Create the fortress room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.MountainRoom(tags=(context.GOAL,)), dident="LOCALE" )
        antagonist = self.elements.get( "ANTAGONIST" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=50, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        fortress.contents.append( team )

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER)] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank-3,self.rank+1,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+1, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            fortress.contents.append( boss )

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.DungeonEntrance()
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        # Add some extra pressure.
        if random.randint(1,4) != 4:
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
        }
        return mygram


# SDI_ENEMY_BARRACKS

# SDI_BLOCKED_GATE

# SDI_HIDDEN_BASE

# SDI_WILD_DUNGEON

# SDI_SUPERWEAPON

# SDI_BIGBOSS
#
# Grammar Tags:
#   [SDI_BIGBOSS:name]   The name of the boss
#   [SDI_BIGBOSS:type]   The type of the boss (optional)
# To do:
# - NPC big boss
# - Smaller boss with a big pet

class BossInABox( SDIPlot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        myscene = maps.Scene( 45,45, sprites={maps.SPRITE_WALL: "terrain_wall_darkbrick.png", 
            maps.SPRITE_FLOOR: "terrain_floor_dungeon.png", }, fac=antagonist,
            biome=context.HAB_BUILDING, setting=self.setting, desctags=(context.MAP_DUNGEON,context.MTY_HUMANOID) )
        igen = randmaps.SubtleMonkeyTunnelScene( myscene )
        self.register_scene( nart, myscene, igen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=50,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.northwest,randmaps.anchors.north,randmaps.anchors.northeast)) )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        myhabitat[ context.MTY_BOSS ] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )

            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) <= self.rank:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True

    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].monster_name,],
            "[warning]":    ["{} is a tough enemy".format(self.elements["ENEMY"]),
                ],
        }
        return mygram


# SDI_AMBUSH
# The party has been ambushed! Oh noes!
# Grammar Tags:
#            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],

# To do:
# - Novice ambush: Arrive after caravan destroyed, talk to survivors, no fight.
# - Too late ambush: Arrive after destruction, fight beasts at site. After
#   battle get message confirming that humanoids were behind the attack.
# - Trap ambush: Find destroyed caravan; searching cart brings out enemies.

class ImmediateAmbush( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        myscene = maps.Scene( 40, 40, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.WildernessPath( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        myent = waypoints.Waypoint()
        ambush_room.contents.append( myent )
        ambush_room.priority = 0
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction( context.GEN_GOBLIN ) )

        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )

        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("Without warning, you are ambushed by forces of the {}!".format(self.elements["ANTAGONIST"]))
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
            self._do_message = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[INTRO]": [ "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                    "You travel to [+SDI_VILLAGE:name] for the annual [thing] festival. The path is peaceful and pleasant... too pleasant.",
                    "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
        }
        return mygram


class AmbushInterrupted( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        myscene = maps.Scene( 60, 60, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.WildernessPath( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.Waypoint()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction( context.GEN_GOBLIN ) )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        friendlies = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        npc = self.register_element( "NPC", monsters.generate_npc(team=friendlies,rank=self.rank),
         dident="_AMBUSHROOM" )
        self._reward_ready = True
        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("You hear the sounds of conflict on the path ahead...")
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            ol.append( dialogue.Offer( "Thanks for your help against the {}, but I fear [warning].".format(self.elements["ANTAGONIST"]) ,
             context = context.ContextTag([context.HELLO]) ) )
        return ol
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[INTRO]": [    "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                "You travel to [+SDI_VILLAGE:name]. This area has recently been attacked by the {}.".format(self.elements["ANTAGONIST"]),
                "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
        }
        return mygram



# SDI_VILLAGE
#
# Grammar Tags:
#    [SDI_VILLAGE:name] The village name, usually "village of #".
#
# To do:
# - Too late village: has already been destroyed, may find survivors. Or not.
# - Orc Prisoners: Village has been captured by orcs; rescue them from mine.
#   Survivors then help you find way to next chapter.
# - Dwarven village: Have to go underground to find it.
# - Elf village: Likewise hidden from plain sight.
# - Fort Under Siege: Barred from entering fort; doors will open after the
#   enemies have been defeated.

class ForestVillage( SDIPlot ):
    LABEL = "SDI_VILLAGE"
    # Create a small village.
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        """Create map, fill with city + services."""
        myscene = maps.Scene( 80, 80, sprites={maps.SPRITE_GROUND: "terrain_ground_forest.png", maps.SPRITE_WALL: "terrain_wall_lightbrick.png"},
            biome=context.HAB_FOREST, setting=self.setting,
            desctags=(context.MAP_WILDERNESS,context.DES_CIVILIZED,) )
        mymapgen = randmaps.WildernessPath( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        castle = self.register_element( "CITY",
         randmaps.rooms.VillageRoom( width=25,height=25,anchor=randmaps.anchors.middle,
         tags=(context.CIVILIZED,context.ROOM_PUBLIC), parent=myscene ) )
        castle.priority = 50
        castleroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=castle )
        myteam = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        castle.contents.append( myteam )
        castleroom.contents.append( monsters.generate_npc(team=myteam) )
        castleroom.contents.append( monsters.generate_npc(team=myteam) )

        # Create the entrance at the beginning
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        self.add_sub_plot( nart, "CITY_GENERALSTORE" )
        self.add_sub_plot( nart, "CITY_INN" )
        self.add_sub_plot( nart, "CITY_TEMPLE" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        #self.add_sub_plot( nart, "TEST_FEATURE", necessary=False )
        return True

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[SDI_VILLAGE:name]": [ "village of {}".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "You arrive in the village of {}. [INTRO_PROBLEM]".format(self.elements["LOCALE"]),
                "This was supposed to be a nice relaxing trip to the {}. Of course, things rarely go according to plan for adventurers.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
        }
        return mygram


# SDI_OUTPOST

# SDI_RECON


