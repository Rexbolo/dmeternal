from plots import Plot,PlotError,PlotState,Chapter
import context
import items
import maps
import randmaps
import waypoints
import monsters
import dialogue
import services
import teams
import characters
import namegen
import random
import container

# Shortie Done-in-one Dungeon Monkey Adventure
# - A small adventure, typically consisting of a single dungeon or wilderness
#   area.
# - Despite the limited area, see how interesting you can make it.
# - This will be dynamically loaded into an existing campaign.

class ShortieStub( Plot ):
    LABEL = "SHORTIE"

    # This plot gets placed in the global scripts and sets itself as the
    # "world" of its chapter. This means that all scenes generated by subplots
    # should be stored inside the plot itself, making cleanup easy. I hope.
    scope = True
    active = False

    SHORTIE_GRAMMAR = {
        # [ADVENTURE] is the top level token- it will expand into a number of
        # high level tokens.
        "[ADVENTURE]": [ "SDI_AMBUSH SDI_VILLAGE SDI_ENEMY_FORT SDI_BOSSFIGHT",
            ],

        "[ENEMY_BASE]": [ "SDI_ENEMY_FORT SDI_ENEMY_BARRACKS",
            ],

        "[ENEMY_GOAL]": [ "SDI_SUPERWEAPON",
            "SDI_BOSSFIGHT"
            ],

        "[IMPERILED_PLACE]": [ "SDI_AMBUSH SDI_VILLAGE",
            ],
    }
    def custom_init( self, nart ):
        """Create the chapter."""
        self.chapter = Chapter( start_rank=nart.start_rank, end_rank=nart.end_rank, world=self )
        self.chapter.root = self
        self.contents = container.ContainerList(owner=self)
        self.rank = nart.start_rank
        if not self.setting:
            self.setting = context.SET_RENFAN

        # Generate a plot outline for the adventure. We will do this using a
        # context free grammar expansion of the token [ADVENTURE]. The resultant
        # string will be a list of subplot request labels.
        subplot_list = self.register_element( "shortie_outline", list( dialogue.grammar.convert_tokens( "[ADVENTURE]", self.SHORTIE_GRAMMAR ).split() ) )
        print subplot_list

        # Assemble the outline into an adventure. Basically, add a subplot of
        # each generated type, in order. Each subplot describes a stage of the
        # mini adventure- usually a single scene, maybe also several scenes or
        # part of a scene, whatever.
        prev_subplot = self
        self.genplots = list()
        ident = None
        for spr in subplot_list:
            if spr is subplot_list[-1]:
                ident = "_conclusion"
            next_subplot = self.add_sub_plot( nart, spr,
                PlotState().based_on(prev_subplot), ident=ident )
            self.genplots.append( next_subplot )
            if prev_subplot != self:
                # Connect the OUT_ENTRANCE of the prev to the IN_ENTRANCE of the
                # next.
                pe,ne = prev_subplot.elements["OUT_ENTRANCE"], next_subplot.elements["IN_ENTRANCE"]
                pe.destination,pe.otherside = next_subplot.elements["IN_SCENE"],ne
                ne.destination,ne.otherside = prev_subplot.elements["OUT_SCENE"],pe
            # That which was new has now become old.
            prev_subplot = next_subplot

        # Set the adventure entrance to the IN_SCENE of the first generated
        # subplot.
        self._adventure_entrance = (self.genplots[0].elements.get( "IN_SCENE" ),self.genplots[0].elements.get( "IN_ENTRANCE" ))
        exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        self.register_element( "_EXIT", exit )
        exit.plot_locked = True

        self._do_message = True

        return True
    def _EXIT_menu( self, thingmenu ):
        thingmenu.desc = "This appears to be the way out."
        thingmenu.add_item( "Leave this adventure.", self.use_exit )
    def use_exit( self, explo ):
        self.end_adventure( explo.camp )

    def begin_adventure( self, camp, exit_destination, exit_entrance ):
        # Unpack the adventure entrance stored during generation.
        self.active = True
        camp.destination,camp.entrance = self._adventure_entrance
        self._adventure_exit = (exit_destination, exit_entrance)

    def end_adventure( self, camp ):
        # Remove this adventure from campaign, move PCs to original place.
        camp.destination,camp.entrance = self._adventure_exit
        camp.scripts.remove( self )
        self.remove()

    def t_START( self, explo ):
        if self._do_message:
            explo.alert( "This subplot remains." )
            self._do_message = False

# Each shortie component should include:
# IN_SCENE,IN_ENTRANCE: Scene/Entrance where the subplot is entered.
# OUT_SCENE, OUT_ENTRANCE: Scene/Entrance where the subplot is exited.
#  -Note that IN_ENTRANCE need not be a valid gate; if not, transit from
#   previous subplot is one-way only.
#  -Also note that the destinations/behaviour of the entrances will be set by
#   the parent SHORTIE plot. If this plot requires control of the entrances
#   itself, move the declared entrance to an intermediate scene and control
#   access to that scene.

class ShortCombatTest( Plot ):
    LABEL = "SDI_TESTCOMBAT"
    active = True
    scope = True
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        myscene = maps.Scene( 50, 50, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.ForestScene( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        # Create the ambush room in the middle- this is where the IN_ENTRANCE
        # will go.
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.Well()
        myroom.contents.append( myent )

        for t in range( random.randint(1,3) ):
            self.add_sub_plot( nart, "ENCOUNTER" )

        room = mymapgen.DEFAULT_ROOM()
        self.register_element( "_ROOM", room, dident="LOCALE" )
        signpost = waypoints.Signpost()
        self.register_element( "_SIGN", signpost, dident="_ROOM" )
        signpost.plot_locked = True
        signpost.mini_map_label = "Signpost"

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", signpost )

        return True
    def _SIGN_menu( self, thingmenu ):
        thingmenu.desc = "This appears to be the way out."
        thingmenu.add_item( "Leave this adventure.", self.use_sign )
    def use_sign( self, explo ):
        self.do_message = True
        self.chapter.root.end_adventure( explo.camp )


#  SDI_ENEMY_FORT
#   There's an enemy fortress to discover in the wilderness, and you need to
#   find a way in. In the simplest case this involves just fighting the guards
#   at the front door.

class BasicCaveHideout( Plot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        myscene = maps.Scene( 60, 60, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.ForestScene( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack()
        myroom.contents.append( myent )

        # Create the fortress room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.MountainRoom(tags=(context.GOAL,)), dident="LOCALE" )
        antagonist = self.elements.get( "ANTAGONIST" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        fortress.contents.append( team )

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER)] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank-3,self.rank+1,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+1, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            fortress.contents.append( boss )

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.DungeonEntrance()
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        # Add some extra pressure.
        for t in range( random.randint(1,3) ):
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True


# SDI_ENEMY_BARRACKS

# SDI_BLOCKED_GATE

# SDI_HIDDEN_BASE

# SDI_WILD_DUNGEON

# SDI_SUPERWEAPON

# SDI_BOSSFIGHT

class BossInABox( Plot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BOSSFIGHT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        myscene = maps.Scene( 35,35, sprites={maps.SPRITE_WALL: "terrain_wall_darkbrick.png", 
            maps.SPRITE_FLOOR: "terrain_floor_dungeon.png", },fac=antagonist,
            biome=context.HAB_BUILDING, setting=self.setting, desctags=(context.MAP_DUNGEON,context.MTY_HUMANOID) )
        igen = randmaps.SubtleMonkeyTunnelScene( myscene )
        self.register_scene( nart, myscene, igen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=50,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = randmaps.anchors.north )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )

            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) > self.rank:
            self.add_sub_plot( nart, "DUNGEON_ARMORY", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = randmaps.anchors.south )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True

    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False


# SDI_AMBUSH
# The party has been ambushed! Oh noes!

class ImmediateAmbush( Plot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        myscene = maps.Scene( 40, 40, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.WildernessPath( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        myent = waypoints.Waypoint()
        ambush_room.contents.append( myent )
        ambush_room.priority = 0
        antagonist = self.elements.get( "ANTAGONIST" )
        if not antagonist:
            antagonist = self.register_element( "ANTAGONIST", teams.AntagonistFaction( context.GEN_GOBLIN ) )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )

        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("Without warning, you are ambushed by forces of the {}!".format(self.elements["ANTAGONIST"]))
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
            self._do_message = False

class AmbushInterrupted( Plot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        myscene = maps.Scene( 60, 60, 
            sprites={maps.SPRITE_WALL: "terrain_wall_woodfort.png", maps.SPRITE_GROUND: "terrain_ground_forest.png",
             maps.SPRITE_FLOOR: "terrain_floor_gravel.png" },
            biome=context.HAB_FOREST, setting=self.setting, fac=self.elements.get("ANTAGONIST"),
            desctags=(context.MAP_WILDERNESS,) )
        mymapgen = randmaps.WildernessPath( myscene )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.Waypoint()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        antagonist = self.elements.get( "ANTAGONIST" )
        if not antagonist:
            antagonist = self.register_element( "ANTAGONIST", teams.AntagonistFaction( context.GEN_GOBLIN ) )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        friendlies = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        npc = self.register_element( "NPC", monsters.generate_npc(team=friendlies,rank=self.rank),
         dident="_AMBUSHROOM" )
        self._reward_ready = True
        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("You hear the sounds of conflict on the path ahead...")
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            ol.append( dialogue.Offer( "Thanks for your help against the {}, but I fear more danger awaits on the road ahead.".format(self.elements["ANTAGONIST"]) ,
             context = context.ContextTag([context.HELLO]) ) )
        return ol



# SDI_VILLAGE

class ForestVillage( Plot ):
    LABEL = "SDI_VILLAGE"
    # Create a small village.
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        """Create map, fill with city + services."""
        myscene = maps.Scene( 80, 80, sprites={maps.SPRITE_GROUND: "terrain_ground_forest.png", maps.SPRITE_WALL: "terrain_wall_lightbrick.png"},
            biome=context.HAB_FOREST, setting=self.setting,
            desctags=(context.MAP_WILDERNESS,context.DES_CIVILIZED,) )
        mymapgen = randmaps.WildernessPath( myscene )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,15)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        castle = self.register_element( "CITY",
         randmaps.rooms.VillageRoom( width=25,height=25,anchor=randmaps.anchors.middle,
         tags=(context.CIVILIZED,context.ROOM_PUBLIC), parent=myscene ) )
        castle.priority = 50
        castleroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=castle )
        myteam = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        castle.contents.append( myteam )
        castleroom.contents.append( monsters.generate_npc(team=myteam) )
        castleroom.contents.append( monsters.generate_npc(team=myteam) )

        # Create the entrance at the beginning
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward()
        last_room.contents.append( myexit )
        last_room.priority = 100

        self.add_sub_plot( nart, "CITY_GENERALSTORE" )
        self.add_sub_plot( nart, "CITY_INN" )
        self.add_sub_plot( nart, "CITY_TEMPLE" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        #self.add_sub_plot( nart, "TEST_FEATURE", necessary=False )
        return True


# SDI_OUTPOST

# SDI_RECON


