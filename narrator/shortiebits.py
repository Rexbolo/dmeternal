from plots import Plot,PlotError,PlotState,Chapter
import context
import items
import maps
import randmaps
import waypoints
import monsters
import dialogue
import services
import teams
import characters
import namegen
import random
import container
import aid
import stats
import effects
import animobs

# Shortie Done-in-one Dungeon Monkey Adventure
# - A small adventure, typically consisting of a single dungeon or wilderness
#   area.
# - Despite the limited area, see how interesting you can make it.
# - This will be dynamically loaded into an existing campaign.

class ShortieStub( Plot ):
    LABEL = "SHORTIE"

    # This plot gets placed in the global scripts and sets itself as the
    # "world" of its chapter. This means that all scenes generated by subplots
    # should be stored inside the plot itself, making cleanup easy. I hope.
    scope = True
    active = False

    SHORTIE_GRAMMAR = {
        # [ADVENTURE] is the top level token- it will expand into a number of
        # high level tokens. These eventually convert into subplot labels.
        "[zADVENTURE]": [ "[IMPERILED_PLACE] [ENEMY_BASE] [ENEMY_GOAL]",
            ],
        "[ADVENTURE]": [ "[IMPERILED_PLACE] [ENEMY_BASE] [ENEMY_GOAL]",
            ],
        "[ENEMY_BASE]": [ "SDI_ENEMY_FORT SDI_ENEMY_BARRACKS",
            "SDI_DANGEROUS_PATH SDI_ENEMY_FORT",
            ],

        "[ENEMY_GOAL]": [ "SDI_BIGBOSS",
            ],

        "[IMPERILED_PLACE]": [ "SDI_AMBUSH SDI_VILLAGE", "SDI_VILLAGE",
            "SDI_DANGEROUS_PATH SDI_DEFILED_PLACE", "SDI_DEFILED_PLACE",
            "SDI_DANGEROUS_PATH SDI_VILLAGE", "SDI_VILLAGE SDI_DEFILED_PLACE"
            ],
    }
    def custom_init( self, nart ):
        """Create the chapter."""
        self.chapter = Chapter( start_rank=nart.start_rank, end_rank=nart.end_rank, world=self )
        self.chapter.root = self
        self.contents = container.ContainerList(owner=self)
        self.rank = nart.start_rank
        if not self.setting:
            self.setting = context.SET_RENFAN

        # Generate a plot outline for the adventure. We will do this using a
        # context free grammar expansion of the token [ADVENTURE]. The resultant
        # string will be a list of subplot request labels.
        # Note that we don't want any repeating tokens, so try 100 times if need be.
        tries = 0
        while tries < 100:
            subplot_list = self.register_element( "SHORTIE_OUTLINE", list( dialogue.grammar.convert_tokens( "[zADVENTURE]", self.SHORTIE_GRAMMAR ).split() ) )
            tries += 1
            if len(subplot_list) == len(set(subplot_list)):
                # No repeat tokens. Let's get out of here.
                break

        # Assemble the outline into an adventure. Basically, add a subplot of
        # each generated type, in order. Each subplot describes a stage of the
        # mini adventure- usually a single scene, maybe also several scenes or
        # part of a scene, whatever.
        prev_subplot = self
        self.genplots = list()
        ident = None
        for spr in subplot_list:
            if spr is subplot_list[-1]:
                ident = "_conclusion"
            next_subplot = self.add_sub_plot( nart, spr,
                PlotState().based_on(prev_subplot), ident=ident )
            self.genplots.append( next_subplot )
            if prev_subplot != self:
                # Connect the OUT_ENTRANCE of the prev to the IN_ENTRANCE of the
                # next.
                pe,ne = prev_subplot.elements["OUT_ENTRANCE"], next_subplot.elements["IN_ENTRANCE"]
                pe.destination,pe.otherside = next_subplot.elements["IN_SCENE"],ne
                ne.destination,ne.otherside = prev_subplot.elements["OUT_SCENE"],pe
            # That which was new has now become old.
            prev_subplot = next_subplot

        # Set the adventure entrance to the IN_SCENE of the first generated
        # subplot.
        self._adventure_entrance = (self.genplots[0].elements.get( "IN_SCENE" ),self.genplots[0].elements.get( "IN_ENTRANCE" ))
        #exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        #self.register_element( "_EXIT", exit )
        #exit.plot_locked = True
        self.mr_subplot = self.genplots[0]

        self._do_message = True

        return True
    def any_duplicates(self,thelist):
        seen = set()
        for x in thelist:
            if x in seen:
                return True
            seen.add(x)
        return False
    def _EXIT_menu( self, thingmenu ):
        thingmenu.desc = "This appears to be the way out."
        thingmenu.add_item( "Leave this adventure.", self.use_exit )
        thingmenu.add_item( "Stay here a bit longer.", None )
    def _ENTRANCE_menu( self, thingmenu ):
        self._EXIT_menu( thingmenu )
    def use_exit( self, explo ):
        explo.alert( "[=CONCLUSION]" )
        explo.give_gold_and_xp( self.rank*150+random.randint(1,200), (self.rank+1)*250 )
        self.end_adventure( explo.camp )
    def _conclusion_WIN( self, explo ):
        # The conclusion has been won. Activate the exit.
        exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        self.register_element( "_EXIT", exit )
        exit.plot_locked = True
        exit = self.genplots[-1].elements.get( "IN_ENTRANCE" )
        self.register_element( "_ENTRANCE", exit )
        exit.plot_locked = True

    def begin_adventure( self, explo, exit_destination, exit_entrance ):
        # Unpack the adventure entrance stored during generation.
        self.active = True
        explo.camp.destination,explo.camp.entrance = self._adventure_entrance
        self._adventure_exit = (exit_destination, exit_entrance)
        explo.alert( "[=INTRO]" )

    def end_adventure( self, camp ):
        # Remove this adventure from campaign, move PCs to original place.
        camp.destination,camp.entrance = self._adventure_exit
        camp.scripts.remove( self )
        self.remove()

    DIALOGUE_GRAMMAR = {
        "[=CONCLUSION]": [ "After [-achievement] and [++achievement], you return home in victory.",
            "After [++achievement], you return to [quest_giver] for your reward.",
            "It's been a busy day, but [++achievement] is finally done. [END_SHORTIE]",
            "It wasn't easy [-achievement] and [++achievement]. [END_SHORTIE]"
            ],
        "[END_SHORTIE]": [ "You return home in victory.", "You return to [quest_giver] for your reward.",
            "Now you can finally begin that vacation.", "The bards will sing of your acts today.",
            ],
        "[=INTRO]": [ "You have been sent to bring [+SDI_BIGBOSS:name] the [+SDI_BIGBOSS:type] to justice. So far you have tracked them to [=location].",
            "The [+SDI_VILLAGE] has called for a hero. [INTRO_PROBLEM]",
            ],
        "[INTRO_PROBLEM]": [ "Travelers passing through [+SDI_AMBUSH:name] have gone missing.",
            "A [+SDI_BIGBOSS:type] named [+SDI_BIGBOSS:name] has been causing problems.",
            "[=SUMMARY]",
            ],
        "[quest_giver]": [ "[-quest_giver]", "[=quest_giver]"
            ],
        "[RUMOUR]": [   "[rumourleadin] [warning].",
            ],
        "[SHORTIE_SUMMARY]": [ "You already know that [-warning].",
            "[=SUMMARY]"
            ],
        "[SHORTIE_PROBLEM]": [ "[++SUMMARY]","[+SUMMARY]"
            ],
        "[warning]": [ "[+warning]","[=warning]",
            ],
    }

    def get_dialogue_grammar( self, npc, explo ):
        """Return any grammar rules appropriate to this situation."""
        gram = dialogue.grammar.absorb( dict(), self.DIALOGUE_GRAMMAR )
        prefix = "-"
        for sp in self.genplots:
            g2 = sp.get_sdi_grammar()
            if sp is self.mr_subplot:
                prefix = "="
            elif prefix == "=":
                prefix = "+"
            for k,v in g2.iteritems():
                a,b,c = k.partition("[")
                mod_k = b + prefix + c
                if mod_k not in gram:
                    gram[mod_k] = list()
                gram[mod_k] += v
                if sp is self.genplots[-1]:
                    # Add a special mention for the conclusion.
                    mod_k = b + "++" + c
                    if mod_k not in gram:
                        gram[mod_k] = list()
                    gram[mod_k] += v
        return gram

    def t_START( self, explo ):
        if self._do_message:
            self._do_message = False
        # Determine the most recently entered subplot...
        for sp in self.genplots:
            if explo.scene is sp.elements["IN_SCENE"]:
                if self.genplots.index(sp) > self.genplots.index(self.mr_subplot):
                    self.mr_subplot = sp
    def t_COMBATOVER( self, explo ):
        # If the party has died, end this plot gracefully.
        if not explo.camp.first_living_pc():
            explo.camp.destination,explo.camp.entrance = self._adventure_exit
            explo.camp.scripts.remove( self )
            self.remove()

class SDIPlot( Plot ):
    # Like a normal plot, but with extra functions for shortie adventures.
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        # Grammar will be prefixed depending on position:
        # "-" for a subplot the PC has already visited
        # "=" for the current subplot
        # "+" for future subplots
        # "++" for the adventure conclusion
        return dict()

# Each shortie component should include:
# IN_SCENE,IN_ENTRANCE: Scene/Entrance where the subplot is entered.
# OUT_SCENE, OUT_ENTRANCE: Scene/Entrance where the subplot is exited.
#  -Note that IN_ENTRANCE need not be a valid gate; if not, transit from
#   previous subplot is one-way only.
#  -If OUT_ENTRANCE is plot_locked, unlock it before triggering WIN.
#
# Each shortie component can define the following SDI grammar tags:
#  [achievement] Subplot's win condition, in gerund (-ing) form. Can be omitted
#           if nothing much was achieved.
#  [GO_QUEST]   Describe the win condition for this subplot in imperative form.
#  [INTRO]  An introduction to be printed if the adventure starts in this
#           subplot.
#  [location]   A location of interest within the subplot. Optional.
#  [quest_giver] The NPC who sent the party on this mission, and will presumably
#           reward them afterward. Keep it current.
#  [SUMMARY]    A summary of subplot's state, written from player-aligned
#     perspective, in simple present tense.
#  [warning]    A caution for the PC. Frequently encountered as a rumour.
#
# 
#

# SDI_DANGEROUS_PATH
#   You have to travel along this road, but it's dangerous.
# Win Condition:
#   Get to the end.
# Grammar Tags:
#   [SDI_DANGEROUS_PATH:location]    The name of the path.
#   [SDI_DANGEROUS_PATH:threat]     The reason why the path is dangerous.
# To do:
# - Divided islands
# - Straightforward with encounter in the middle
# - Bandit lair: Lots of thieves
# - Murder house: Middle Earth Chainsaw Massacre
# - Through the mines: Over the mountain or through it

class ShortWildernessPath( SDIPlot ):
    LABEL = "SDI_DANGEROUS_PATH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    @classmethod
    def matches( self, pstate ):
        return pstate.rank < 5
    def custom_init( self, nart ):
        # Create the wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )
        myscene.desctags.append( context.MTY_BEAST )
        #myscene.contents.append( randmaps.rooms.FuzzyRoom() )
        #myscene.contents.append( randmaps.rooms.FuzzyRoom() )

        self._do_message = True

        # Add some extra pressure.
        for t in range( random.randint(1,2) ):
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        elif random.randint(1,6) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Create the scene entrance and exit on opposite ends of the map.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
        myroom1 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom1.contents.append( myent )

        myroom2 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_b )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        myroom2.contents.append( myexit )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "crossing the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:threat]": ["wild beasts",
                ],
            "[SUMMARY]": [ "The {} is a dangerous place.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "the {} is home to many dangerous beasts".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("This stretch of wilderness is completely untamed. You will have to find your way through it to get where you're going.")
            explo.check_trigger( "WIN", self )
            self._do_message = False

class BasicWildernessPath( SDIPlot ):
    LABEL = "SDI_DANGEROUS_PATH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    @classmethod
    def matches( self, pstate ):
        return pstate.rank > 1
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        self._do_message = True

        # Add an opportunity for extra treasure.
        self.add_sub_plot( nart, "SUPPLEMENTAL_TREASURE" )

        # Add some extra pressure.
        for t in range( random.randint(1,3) ):
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) != 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Create the scene entrance and exit on opposite ends of the map.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
        myroom1 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom1.contents.append( myent )

        myroom2 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_b )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        myroom2.contents.append( myexit )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "crossing the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:threat]": ["monsters",
                ],
            "[SUMMARY]": [ "There is a hidden danger in the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "many have disappeared in the {}".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("You will have to find your way through this wilderness to get where you're going.")
            explo.check_trigger( "WIN", self )
            self._do_message = False



# SDI_DEFILED_PLACE
#   This place, a shrine or glade or whatnot, has been desecrated, blasphemed,
#   or just plain old ransacked.
# Win Condition:
#   Secure the area. May involve defeating leftover raiders, stabilizing a
#   magical meltdown, or what-have-you. Use your imagination!
# Grammar Tags:
#   [SDI_DEFILED_PLACE:location]    The name of the place that was defiled.
# To do:
# - Sacred Grove Burnt Down
# - Ransacked Temple
# - Grave Robbers: Bodies stolen, set enemy as undead faction
# - Grafitti: Set enemy as Chaos

class GroveBattle( SDIPlot ):
    LABEL = "SDI_DEFILED_PLACE"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Grove","{0} Forest")
    @classmethod
    def matches( self, pstate ):
        return ( pstate.rank > 2 and ( not pstate.elements.get("BIOME") or
                pstate.elements["BIOME"].biome in (context.HAB_FOREST,) ))
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.register_element( "BIOME", randmaps.architect.Forest() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.WildernessPath, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=300, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        myhab = myscene.get_encounter_request()
        myhab[context.MTY_BEAST] = True
        myhab[context.GEN_NATURE] = context.MAYBE
        friendlies = teams.Team( strength=150, default_reaction=characters.SAFELY_FRIENDLY,
         rank=self.rank, habitat=myhab)
        ambush_room.contents.append( friendlies )
        npc = self.register_element( "NPC",
         monsters.generate_npc(team=friendlies,rank=self.rank+1,upgrade=True,
         job=characters.Druid),dident="_AMBUSHROOM" )
        friendlies.boss = npc
        self._reward_ready = True
        self._do_message = True
        ambush_room.contents.append( waypoints.TreeStump(anchor=randmaps.anchors.middle,
         desc="You stand before the stump of what was once a mighty tree, before it was callously destroyed by the {}.".format(antagonist)
         ))

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # After combat, the druid of the grove can provide temple services
        # if they survive.
        self.shop = services.Temple()

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("The normal quiet of {} has been replaced by the sounds of conflict.".format(self.elements["LOCALE"]))
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            explo.check_trigger( "WIN", self )
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            if self.subplots["next"].active:
                ol.append( dialogue.Offer( "Thanks for your help against the {}, but we were too late to save the blessed tree.".format(self.elements["ANTAGONIST"]) ,
                 context = context.ContextTag([context.HELLO]) ) )
            ol.append( dialogue.Offer( "[SERVICE_TEMPLE]" ,
             context = context.ContextTag([context.SERVICE,context.HEALING]), effect=self.shop ) )
        return ol
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "avenging the sacred tree of {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Seek the druid of {}.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [    "Your party decides to travel to {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_DEFILED_PLACE:location]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "not even the trees are safe",
                ],
            "[SUMMARY]": [ "The sacred tree of {} has been destroyed by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        if self.elements["NPC"].is_alright() and not self._reward_ready:
            mygram["[achievement]"] = [ "saving {} from the {}".format(self.elements["NPC"],self.elements["ANTAGONIST"]),
                ]
        return mygram


class ElementalShrine( SDIPlot ):
    LABEL = "SDI_DEFILED_PLACE"
    active = True
    scope = True
    NAME_PATTERNS = { context.DES_EARTH: "{} of Earth", context.DES_AIR: "{} of Air",
        context.DES_WATER: "{} of Water", context.DES_FIRE: "{} of Fire"
        }
    BUILDING_TYPES = ("Shrine","Temple")
    ELEMENTS = (context.DES_EARTH,context.DES_WATER,context.DES_AIR,context.DES_FIRE)
    INTRO_PROBLEM = { context.DES_EARTH: "the earth has begun to rot",
        context.DES_AIR: "the wind has stopped",
        context.DES_WATER: "the sea has gone wild",
        context.DES_FIRE: "the world is veiled in darkness"
        }
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        self._theme = random.choice( self.ELEMENTS )
        archi = self.register_element( "ARCHITECTURE",
         randmaps.architect.TempleArchitecture())
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.desctags.append( self._theme )
        myscene.name = self.NAME_PATTERNS[self._theme].format(random.choice( self.BUILDING_TYPES ))

        # Create the temple exterior.
        fortress = randmaps.rooms.CastleRoom( parent=myscene,width=21,height=21,
          tags=(context.GOAL,))
        exterior = randmaps.rooms.BuildingRoom( parent=fortress,
         tags=(context.CIVILIZED,) )
        exterior.special_c[ "window" ] = maps.SMALL_WINDOW
        gate_1 = waypoints.GateDoor()
        gate_1.mini_map_label = "Shrine"
        exterior.special_c[ "door" ] = gate_1

        interior,igen = randmaps.architect.design_scene( 40, 40,
          randmaps.BuildingScene, archi, setting=self.setting)
        self.register_scene( nart, interior, igen, ident="_TEMPLE", dident="LOCALE" )
        interior.desctags.append( self._theme )
        interior.name = "{} Interior".format( myscene.name )
        int_mainroom = randmaps.rooms.SharpRoom( width=9,height=9,
          anchor=randmaps.anchors.south, parent=interior )
        gate_2 = waypoints.GateDoor()
        int_mainroom.contents.append( gate_2 )
        int_mainroom.DECORATE = randmaps.decor.TempleDec()
        gate_2.anchor = randmaps.anchors.south

        crystal = self.register_element( "_CRYSTAL", waypoints.PowerCrystal(plot_locked=True))
        crystal.anchor = randmaps.anchors.middle
        int_mainroom.contents.append( crystal )

        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=0, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        int_mainroom.contents.append( team )

        myhabitat = { self._theme: True, context.MTY_ELEMENTAL: context.MAYBE, context.MTY_CELESTIAL: context.MAYBE,
         (context.MTY_BEAST,context.MTY_UNDEAD,context.MTY_CONSTRUCT,context.MTY_CELESTIAL,context.MTY_ELEMENTAL): True,
         }
        btype = monsters.choose_monster_type(self.rank-1,self.rank+2,myhabitat)
        if btype:
            boss = self.register_element("_MONSTER",monsters.generate_boss( btype, self.rank+2, team=team ))
            boss.name = "Crystal Spirit"
            int_mainroom.contents.append( boss )

        gate_1.destination = interior
        gate_1.otherside = gate_2
        gate_2.destination = myscene
        gate_2.otherside = gate_1

        # Create the scene entrance and exit on opposite ends of the map.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
        myroom1 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom1.contents.append( myent )

        myroom2 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_b )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        myroom2.contents.append( myexit )
        myexit.plot_locked = True
        self._door_locked = True
        self._do_message = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return btype
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "pacifying the {}".format(self.elements["LOCALE"]),
                ],
            "[CONCLUSION]": ["The spirits at the {} have been pacified. [END_SHORTIE]".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Go see what has happened to the {}, and defend it if necessary.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]":  ["Your wanderings have brought you close to the {}. However, something seems to be wrong there.".format(self.elements["LOCALE"]),
                "There has been a series of bad omens; {}. Your party travels to the {} to discover the cause.".format(self.INTRO_PROBLEM[self._theme],self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DEFILED_PLACE:location]": [str(self.elements["LOCALE"]),
                ],
            # A special tag, used after the spirit is calmed.
            "[SDI_DEFILED_PLACE:ending]": [ "The question is, who would dare to desecrate this place?",
                "This must have been the work of [+SDI_BIGBOSS:name] the [SDI_BIGBOSS:type].",
                "This must be related to the trouble [quest_giver] warned you about.",
                "The ones who did this must have come from [+SDI_ENEMY_BARRACKS:name]; that's where you will find answers.",
                "Maybe you will discover who did this, and why, in [+location].",
                ],
            "[SUMMARY]": [ "There has been a disturbance at the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "the {} has been defiled".format(str(self.elements["LOCALE"])),
                self.INTRO_PROBLEM[self._theme]
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._do_message and explo.scene is self.elements["_TEMPLE"]:
            explo.alert("You sense evil as you enter the room. Without warning, the guardian of the crystal attacks!")
            self._do_message = False
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
    def _open_the_exit( self,explo ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.check_trigger( "WIN", self )
    def _smash_crystal( self, explo ):
        if explo.bumper.get_stat( stats.STRENGTH ) + random.randint(1,20) > 20:
            explo.alert("You strike the crystal, shattering it into a million pieces. The crystal guardian lets out an otherworldly shriek before fading into nothingness.")
            self._open_the_exit( explo )
            self.elements["TEAM"].default_reaction = 999
            explo.scene.contents.remove(self.elements["_MONSTER"])
            explo.camp.fight.active.remove(self.elements["_MONSTER"])
            explo.alert("The spirit has been destroyed. [=SDI_DEFILED_PLACE:ending]")
        else:
            explo.alert("You strike the crystal, but don't even manage to scratch it.")
    def _repair_crystal( self, explo ):
        if (explo.bumper.get_stat( stats.MAGIC_ATTACK ) + explo.bumper.get_stat_bonus( stats.PIETY ) + random.randint(1,100)) > (45 + 4 * self.rank):
            explo.alert("You touch the crystal. You are overwhelmed by the negative energy...")
            explo.alert("Concentrating through the pain, you make mental contact with the crystal spirit. It peers deep into your soul, then decides you are not the one who attacked this place.")
            explo.alert("The spirit fades away. The crystal begins to glow with a steady light once more.")
            self._open_the_exit( explo )
            self.elements["TEAM"].default_reaction = 999
            explo.scene.contents.remove(self.elements["_MONSTER"])
            explo.give_gold_and_xp( 0, 100 * self.rank + 50 )
            explo.alert("The spirit has been calmed. [=SDI_DEFILED_PLACE:ending]")
            self.elements["_CRYSTAL"].plot_locked = False
        else:
            explo.alert("You touch the crystal. You are overwhelmed by the negative energy!")
            explo.invoke_effect( self.CRYSTAL_SHOCK, None, (explo.bumper.pos,) )
    CRYSTAL_SHOCK = effects.NoEffect( children = (
        effects.HealthDamage((1,6,0), stat_bonus=None, element=stats.RESIST_SOLAR, anim=animobs.YellowExplosion ),
        effects.ManaDamage((2,6,0), stat_bonus=None, anim=animobs.PurpleExplosion ),
    ))
    def _CRYSTAL_menu( self, thingmenu ):
        if self._door_locked:
            thingmenu.desc = "The elemental crystal is flickering wildly. Something terrible must have happened here."
            thingmenu.add_item( "Smash the crystal", self._smash_crystal )
            thingmenu.add_item( "Touch the crystal", self._repair_crystal )
            thingmenu.add_item( "Leave it alone", None )
        else:
            thingmenu.desc = "The elemental crystal has gone cold and dark."
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "You should find out what happened at the {} before leaving.".format(self.elements["LOCALE"])
    def t_COMBATOVER( self, explo ):
        if explo.scene is self.elements["_TEMPLE"] and self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            explo.alert("The spirit has been calmed. [=SDI_DEFILED_PLACE:ending]")
            self._open_the_exit(explo)

#  SDI_ENEMY_FORT
#   There's an enemy fortress to discover in the wilderness, and you need to
#   find a way in. In the simplest case this involves just fighting the guards
#   at the front door.
# Win Condition:
#   Gain access to the fortress. This may be as simple as showing up.
# Grammar Tags:
#   [SDI_ENEMY_FORT:location]   The rough location of the enemy fort
# To do:
# - Well-guarded and obvious fortress.
# - Pet guarded gate
# - Locked fortress
# - Can of Wyrms: Small courtyard full of enemies with unlocked puzzle door.
# - Unguarded fortress for low levels.

class BasicCaveHideout( SDIPlot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the fortress room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.MountainRoom(tags=(context.GOAL,)), dident="LOCALE" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=150, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        fortress.contents.append( team )

        # Register the cave stuff.
        self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.CavernDungeon(antagonist) )

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER)] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank-3,self.rank+1,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+1, team=team )
            myitem = items.generate_special_item( self.rank )
            if myitem:
                boss.contents.append( myitem )
            fortress.contents.append( boss )
            team.boss = boss

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.DungeonEntrance()
        myexit.mini_map_label = "Cave Fortress"
        myexit.plot_locked = True
        self._door_locked = True
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        # Add some extra pressure.
        if random.randint(1,4) != 4:
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "locating the {} cave".format(self.elements["ANTAGONIST"]),
                ],
            "[GO_QUEST]": ["Gain access to the enemy fortress in the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} have been spotted near a cave in the {}.".format(self.elements["ANTAGONIST"],str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "there is a cave in the {} which is home to the {}".format(str(self.elements["LOCALE"]),self.elements["ANTAGONIST"]),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to enter the cave.")
            explo.check_trigger( "WIN", self )

class GuardedFortress( SDIPlot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.BuildingDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the fortress room and the guards.
        fortress = randmaps.rooms.CastleRoom( parent=myscene,width=21,height=21,
          tags=(context.GOAL,))
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=150, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        fortress.contents.append( team )
        fortroom = randmaps.rooms.FuzzyRoom(parent=fortress)

        # Also add a reward- either straight up treasure chests, or an NPC boss
        # who will probably be carrying some nice gear.
        if random.randint(1,2) == 1:
            boss = monsters.generate_npc( rank=self.rank, team=team, fac=antagonist, upgrade=True )
            fortress.contents.append( boss )
            team.boss = boss
        else:
            mychest = waypoints.MediumChest()
            mychest.stock(self.rank)
            fortroom.contents.append( mychest )

        # Create the scene entrance
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the exit... which in this case is the fortress inside the walls.
        exterior = randmaps.rooms.BuildingRoom( parent=fortress,
         tags=(context.CIVILIZED,) )
        exterior.special_c[ "window" ] = maps.SMALL_WINDOW
        myexit = waypoints.GateDoor()
        myexit.mini_map_label = "Fortress"
        myexit.plot_locked = True
        exterior.special_c[ "door" ] = myexit
        self._door_locked = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "raiding the enemy base",
                ],
            "[GO_QUEST]": ["Gain access to the enemy fortress in the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "There's an enemy base in the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "the fortress in the {} is very well guarded".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to enter the fortress.")
            explo.check_trigger( "WIN", self )


# SDI_ENEMY_BARRACKS
#   The active base of a particular faction or group of monsters, as opposed to
#   a ruin or natural cave system.
#
# Win Condition:
#   Establish control or just get through it.
# Grammar Tags:
#   [SDI_ENEMY_BARRACKS:name]   The name of the base
# To do:
#

class BasicBarracks( SDIPlot ):
    # A simple dungeon level.
    LABEL = "SDI_ENEMY_BARRACKS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Barracks","{0} Base")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( random.randint(50,65),
          random.randint(50,65), randmaps.SubtleMonkeyTunnelScene,
          biome, setting=self.setting, fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( antagonist )
        myscene.desctags.append( context.MTY_HUMANOID )
        mymapgen.GAPFILL = None

        # Determine room anchors.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_CARDINALS)

        team = self.register_element( "TEAM", 
         teams.Team(default_reaction=-999, rank=self.rank, strength=100,
         habitat=myscene.get_encounter_request(), fac=antagonist,
         respawn=False ))
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
          anchor=anc_a )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        goalroom.contents.append(door2)
        door2.plot_locked = True
        door2.anchor = anc_a
        self._door_locked = True
        mychest = waypoints.MediumChest()
        mychest.stock(self.rank)
        goalroom.contents.append( mychest )

        n = random.randint(1,3)
        for t in range( n ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        for t in range( 4-n ):
            self.add_sub_plot( nart, "DUTILITY_ROOM", PlotState().based_on( self ) )
        if random.randint(1,3) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,3) != 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.GateDoor()
        door1.anchor = anc_b
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to pass this way.")
            explo.check_trigger( "WIN", self )
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "infiltrating the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Infiltrate the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_ENEMY_BARRACKS:name]": [str(self.elements["LOCALE"]),],
            "[SUMMARY]": [ "The {} have many soldiers at their base.".format(str(self.elements["ANTAGONIST"])),
                ],
            "[warning]":    ["few who enter {} return alive".format(self.elements["LOCALE"]),
                ],
        }
        return mygram


# SDI_BLOCKED_GATE

# SDI_HIDDEN_BASE

# SDI_WILD_DUNGEON

# SDI_SUPERWEAPON

# SDI_BIGBOSS
#
# Win Condition:
#   Kill the boss, usually.
# Grammar Tags:
#   [SDI_BIGBOSS:name]   The name of the boss
#   [SDI_BIGBOSS:type]   The type of the boss (optional)
# To do:
# - Smaller boss with a big pet

class BossInABox( SDIPlot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 45, 45,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=200,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.northwest,randmaps.anchors.north,randmaps.anchors.northeast)) )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_BOSS,context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )
            team.boss = boss
            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) <= self.rank:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Defeat {}.".format(self.elements["ENEMY"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].monster_name,],
            "[SUMMARY]": [ "{} is a [negative_adjective] {}.".format(str(self.elements["ENEMY"]),self.elements["ENEMY"].monster_name),
                ],
            "[warning]":    ["{} is a tough enemy".format(self.elements["ENEMY"]),
                ],
        }
        return mygram

class NPCBossInABox( SDIPlot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 45, 45,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=250,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.northwest,randmaps.anchors.north,randmaps.anchors.northeast)) )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        if self.rank < random.randint(2,4):
            brank = self.rank + 2
        elif self.rank < random.randint(6,10):
            brank = self.rank + 3
        else:
            brank = self.rank + 4
        boss = monsters.generate_npc( rank=brank, team=team, fac=antagonist, upgrade=True )
        goalroom.contents.append( boss )
        self.register_element( "ENEMY", boss )
        team.boss = boss
        myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) <= self.rank:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Defeat {}.".format(self.elements["ENEMY"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].mr_level.name,],
            "[SUMMARY]": [ "{} is an evil {}.".format(str(self.elements["ENEMY"]),self.elements["ENEMY"].mr_level.name),
                ],
            "[warning]":    ["{} will kill anyone that opposes {}".format(self.elements["ENEMY"],self.elements["ENEMY"].object_pronoun()),
                ],
        }
        return mygram


# SDI_AMBUSH
# The party has been ambushed! Oh noes!
#
# Win Condition:
#   Just show up, usually. Surviving is its own reward.
# Grammar Tags:
#   "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
# To do:
# - Novice ambush: Arrive after caravan destroyed, talk to survivors, no fight.
# - Too late ambush: Arrive after destruction, fight beasts at site. After
#   battle get message confirming that humanoids were behind the attack.
# - Trap ambush: Find destroyed caravan; searching cart brings out enemies.

class ImmediateAmbush( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    @classmethod
    def matches( self, pstate ):
        """Requires the SCENE to exist."""
        return pstate.rank > 2
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 40, 40,
          randmaps.WildernessPath, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        myent = waypoints.Waypoint()
        ambush_room.contents.append( myent )
        ambush_room.priority = 0
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )

        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )

        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("Without warning, you are ambushed by forces of the {}!".format(self.elements["ANTAGONIST"]))
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
            explo.check_trigger( "WIN", self )
            self._do_message = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "battling the {} on the {}".format(self.elements["ANTAGONIST"],self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["The {} will take you where you need to go.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                    "You travel to [+SDI_VILLAGE:name] for the annual [thing] festival. The path is peaceful and pleasant... too pleasant.",
                    "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
            "[SUMMARY]": [ "The {} has frequently been attacked by {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        return mygram


class AmbushInterrupted( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.WildernessPath, biome, setting=self.setting,
          fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.Waypoint()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        friendlies = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        npc = self.register_element( "NPC",
         monsters.generate_npc(team=friendlies,rank=self.rank+1,upgrade=True),
         dident="_AMBUSHROOM" )
        self._reward_ready = True
        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("You hear the sounds of conflict on the path ahead...")
            explo.check_trigger( "WIN", self )
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            ol.append( dialogue.Offer( "Thanks for your help against the {}, but I fear [warning].".format(self.elements["ANTAGONIST"]) ,
             context = context.ContextTag([context.HELLO]) ) )
        return ol
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["The {} will take you where you need to go.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [    "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                "You travel to [+SDI_VILLAGE:name]. This area has recently been attacked by the {}.".format(self.elements["ANTAGONIST"]),
                "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
            "[SUMMARY]": [ "The {} has frequently been attacked by {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        if self.elements["NPC"].is_alright() and not self._reward_ready:
            mygram["[achievement]"] = [ "saving {} from the {}".format(self.elements["NPC"],self.elements["ANTAGONIST"]),
                ]
        return mygram



# SDI_VILLAGE
#
# Win Condition:
#   Just show up, usually. A village is its own reward.
# Grammar Tags:
#    [SDI_VILLAGE:name] The village name
# To do:
# - Too late village: has already been destroyed, may find survivors. Or not.
# - Orc Prisoners: Village has been captured by orcs; rescue them from mine.
#   Survivors then help you find way to next chapter.
# - Dwarven village: Have to go underground to find it.
# - Elf village: Likewise hidden from plain sight.
# - Fort Under Siege: Barred from entering fort; doors will open after the
#   enemies have been defeated.
# - Hot Springs Village: Healing location, priestly stuff.
# - Nature Village: Druidish and rangerish stuff. Stonehenge?
# - Secret Magic Village: Wizardly stuff.
# - Athletic Village: Warrior stuff.
# - Hermit Village: Hey hey we're the monk-ees.

class BoringVillage( SDIPlot ):
    LABEL = "SDI_VILLAGE"
    # Create a small village. Add an NPC to provide advice and help.
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        """Create map, fill with city + services."""
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "ARCHITECTURE", randmaps.architect.Village(biome.biome))
        culture = self.register_element( "CULTURE", teams.PolisFaction(dungeon_type=("Village","Hamlet")) )
        myscene,mymapgen = randmaps.architect.design_scene( 80, 80,
          randmaps.WildernessPath, biome,fac=culture,secondary=archi,setting=self.setting)
        myscene.desctags.append( context.DES_CIVILIZED )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = culture.name

        castle = self.register_element( "CITY",
         randmaps.rooms.VillageRoom( width=25,height=25,anchor=randmaps.anchors.middle,
         tags=(context.CIVILIZED,context.ROOM_PUBLIC), parent=myscene ) )
        castle.priority = 50
        castleroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=castle )
        myteam = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        castle.contents.append( myteam )
        castleroom.contents.append( monsters.generate_npc(team=myteam,fac=culture) )
        castleroom.contents.append( monsters.generate_npc(team=myteam,fac=culture) )

        # Create the village elder.
        elder = monsters.generate_npc(team=myteam,rank=self.rank+1,
          job=monsters.base.Elder,upgrade=True,fac=culture)
        self.register_element("NPC",elder)
        castleroom.contents.append(elder)
        self._reward_given = False

        # Create the entrance at the beginning
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        self._message_ready = True

        self.add_sub_plot( nart, "VILLAGE_RANDOMSHOP" )
        self.add_sub_plot( nart, "CITY_INN" )
        self.add_sub_plot( nart, "CITY_TEMPLE" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        #self.add_sub_plot( nart, "TEST_FEATURE", necessary=False )
        return True

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[SDI_VILLAGE:name]": [ str(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "You arrive in the {}. [INTRO_PROBLEM]".format(self.elements["LOCALE"]),
                "This was supposed to be a nice relaxing trip to the {}. Of course, things rarely go according to plan for adventurers.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} has seen better times.".format(self.elements["LOCALE"]),
                "The {} lives in fear of [+SDI_BIGBOSS:name].".format(self.elements["LOCALE"]),
                "The {} is under attack by enemies who come from [+SDI_ENEMY_FORT:location].".format(self.elements["LOCALE"]),
                ],
        }
        if self._reward_given:
            mygram["[quest_giver]"] = [str(self.elements["NPC"]),]
        return mygram
    def accept_quest( self, explo ):
        self._reward(explo)
        self._reward_given = True
    def reject_quest( self, explo ):
        self.chapter.root.end_adventure(explo.camp)
    def NPC_offers( self, explo ):
        ol = list()
        if not hasattr( self, "_reward" ):
            # Generate aid for the NPC to give the party.
            self._reward = aid.ProvisionAid( self.rank, explo.camp,
             self.elements["NPC"],
             self.chapter.root.genplots[-1].elements.get("ENEMY"),
             self.elements.get("ANTAGONIST"))
        if self is not self.chapter.root.genplots[-1] and not self._reward_given:
            r1 = dialogue.Reply( "Yes, we will.",
             destination=dialogue.Offer( "[+GO_QUEST] {}".format( self._reward.get_speech() ),
             effect=self.accept_quest ) )
            r2 = dialogue.Reply( "No thanks.",
             destination=dialogue.Offer( "[REFUSE_QUEST]",
             effect=self.reject_quest ) )
            ol.append( dialogue.Offer( "[SHORTIE_SUMMARY] [SHORTIE_PROBLEM] Will you help us?",
             context = context.ContextTag([context.PROBLEM,context.LOCAL]),
             replies = [r1,r2] ) )
        else:
            pass
        return ol
    def t_START( self, explo ):
        if self._message_ready:
            self._message_ready = False
            explo.check_trigger( "WIN", self )



# SDI_OUTPOST

# SDI_RECON


